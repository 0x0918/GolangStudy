# Go 调度：章节1 - 操作系统调度

## 序

这是一个由三章节组成的系列文章的第一章节。该系列文章将提供对 Go 的调度器背后的机制和语义的理解。本文主要讨论操作系统调度器。

三章节文章索引：

1. [Go 调度：章节1 - 操作系统调度](/docs/go-go调度-章节1.md)
2. [Go 调度：章节2 - Go 语言调度](/docs/go-go调度-章节2.md)
3. [Go 调度：章节3 - 并发](/docs/go-go调度-章节3.md)

## 介绍

Go 调度器的设计和能力允许你的多线程 Go 程序更高效，更高性能。这个要得益于 Go 调度器对操作系统调度器的充分调优。但是，如果多线程 Go 软件的设计和行为与调度器的工作方式没有机械上的一致性，那么一切都会变得无关紧要，Go 的优点将无法发挥。对操作系统和 Go 调度器有一个全面的，有代表性的理解对于如何正确设计多线程软件是很重要的。

这篇由多个章节组成的文章将重点讨论调度器的高级机制和语义。我将提供足够的细节，让你能够理解调度器是如何运作的，这样你就可以作出更好的工程上的决策。尽管需要为多线程应用作出很多工程上的决策，但机制和语义构成了所需基础知识的关键部分。

## 操作系统调度

操作系统调度是复杂的软件。他们必须考虑他们运行的硬件的布局和设置。这个复杂度包括但不限于多核处理器和内核，CPU 缓存和 NUMA（Non Uniform Memory Access 非统一内存访问）。没有这些知识，调度程序就不能尽可能地高效。最好是，你可以开发一个很好的操作系统调度器工作的核心模型，就不必深入研究这些内容。

你的程序只是一系列需要依次执行的机器指令。为了实现这个功能，操作系统使用了线程的概念。线程的任务是解释并顺序执行分配给它的指令集。这个执行将持续进行直到线程没有更多要执行的指令为止。这就是为什么我称线程为"执行序列"。

每个程序的运行都会创建一个进程，每个进程都有一个初始线程。初始线程具有创建更多线程的能力。所有这些不同的线程彼此独立运行，调度决策是在线程级别而不是在进程级别作出的。线程可以并发运行（每个线程在单个内核上轮流运行），也可以并行运行（每个线程在不同的内核上同时运行）。线程还保持自己的状态，以允许安全，本地（local）和独立地执行指令。

如果存在可以执行的线程，操作系统调度程序负责确保内核不处于空闲状态。它还必须产生一种错觉，即所有可以执行的线程都在同时执行。在创造这个错觉的过程中，调度程序需要以比较高的优先级来运行线程。但是，优先级较低的线程不能缺乏执行时间。调度器还需要通过作出快速和智能的决策，尽可能地减少调度延迟。

为了实现这一点，操作系统在算法方面做了大量的工作，幸运的是，业界有几十年的工作和经验可以利用。为了更好地理解这些，最好描述和定义一些重要的概念。

## 执行指令（Executing Instructions）

程序计数器（program counter PC）有时被称为指令指针（instruction pointer IP）

![go-go调度-章节1-指令指针.jpeg](https://cnymw.github.io/GolangStudy/docs/img/go-go调度-章节1-指令指针.jpeg)

如果你曾经看到过 Go 程序的堆栈跟踪，你可能已经注意到每行末尾的这些十六进制数。可以看以下 Listing 1：

#### Listing 1

```go
goroutine 1 [running]:
   main.example(0xc000042748, 0x2, 0x4, 0x106abae, 0x5, 0xa)
       stack_trace/example1/example1.go:13 +0x39                 <- LOOK HERE
   main.main()
       stack_trace/example1/example1.go:8 +0x72                  <- LOOK HERE
```