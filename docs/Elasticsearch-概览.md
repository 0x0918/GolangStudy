# Elasticsearch 概览

## 生活中的数据

搜索引擎是对数据的检索，所以我们先从生活中的数据说起。

### 数据分类

我们生活中的数据总体分为两种：

1. 结构化数据：也称作行数据，是由二维表结构来逻辑表达和实现的数据，严格地遵循数据格式与长度规范，主要通过关系型数据库进行存储和管理。指具有固定格式或有限长度的数据，如数据库，元数据等。

2. 非结构化数据：又可称为全文数据，不定长或无固定格式，不适于由数据库二维表来表现，包括所有格式的办公文档、XML、HTML、word 文档，邮件，各类报表、图片和咅频、视频信息等。

### 搜索数据

根据数据分类，搜索也相应的分为两种：

1. 结构化数据搜索：结构化数据因为具有特定的结构，所以我们一般都是可以通过关系型数据库（mysql，oracle 等）的二维表（table）的方式存储和搜索，也可以建立索引。

2. 非结构化数据搜索

    - 顺序扫描法：按照顺序扫描的方式查询特定的关键字

    - 全文检索：将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，重新组织的信息称之为索引，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的

## Lucene

非结构化数据的处理需要依赖全文搜索，而目前市场上开放源代码的最好全文检索引擎工具包就属于 apache 的 Lucene了。

Lucene 只是一个工具包，它不是一个完整的全文检索引擎。目前以 Lucene 为基础建立的开源可用全文搜索引擎主要是 Solr 和 Elasticsearch。

### 倒排索引

Lucene 能实现全文搜索主要是因为它实现了倒排索引的查询结构。

如何理解倒排索引呢？假如现有三份数据文档，文档的内容如下分别是：

- Java is the best programming language.

- PHP is the best programming language.

- Javascript is the best programming language.

为了创建倒排索引，我们通过分词器将每个文档的内容域拆分成单独的词（我们称它为词条或 Term），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：

```text
Term          Doc_1    Doc_2   Doc_3
-------------------------------------
Java        |   X   |        |
is          |   X   |   X    |   X
the         |   X   |   X    |   X
best        |   X   |   X    |   X
programming |   x   |   X    |   X
language    |   X   |   X    |   X
PHP         |       |   X    |
Javascript  |       |        |   X
-------------------------------------
```

这种结构由文档中所有不重复词的列表构成，对于其中每个词都有一个文档列表与之关联。这种由属性值来确定记录的位置的结构就是倒排索引。带有倒排索引的文件我们称为倒排文件。

我们将上面的内容转换为图的形式来说明倒排索引的结构信息，如下图所示：

![Elasticsearch-概览-倒排索引.png](https://cnymw.github.io/GolangStudy/docs/img/Elasticsearch-概览-倒排索引.png)

其中主要有如下几个核心术语需要理解：

- 词条(Term)：索引里面最小的存储和查询单元，对于英文来说是一个单词，对于中文来说一般指分词后的一个词。

- 词典(Term Dictionary)：或字典，是词条 Term 的集合。搜索引擎的通常索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。

- 倒排表(Post list)：一个文档通常由多个词组成，倒排表记录的是某个词在哪些文档里出现过以及出现的位置。每条记录称为一个倒排项(Posting)。倒排表记录的不单是文档编号，还存储了词频等信息。

- 倒排文件(Inverted File)：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件被称之为倒排文件，倒排文件是存储倒排索引的物理文件。

## 核心概念

ES 是使用 Java 编写的一种开源搜索引擎，它在内部使用 Lucene 做索引与搜索，通过对 Lucene 的封装，隐藏了 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。


然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。它可以被下面这样准确的形容：

- 一个分布式的实时文档存储，每个字段可以被索引与搜索。

- 一个分布式实时分析搜索引擎。

- 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。

### 集群（Cluster）

ES 集群由一个或多个 Elasticsearch 节点组成，每个节点配置相同的 `cluster.name` 即可加入集群，默认值为 “elasticsearch”。确保不同的环境中使用不同的集群名称，否则最终会导致节点加入错误的集群。

一个 Elasticsearch 服务启动实例就是一个节点（Node）。节点通过 `node.name` 来设置节点名称，如果不设置则在启动时给节点分配一个随机通用唯一标识符作为名称。

#### 发现机制

ES 内部通过 Zen Discovery 将同样配置 `cluster.name` 的节点连接到同一个集群。

Zen Discovery 是 Elasticsearch 的内置默认发现模块（发现模块的职责是发现集群中的节点以及选举 master 节点）。它提供单播和基于文件的发现，并且可以扩展为通过插件支持云环境和其他形式的发现。Zen Discovery 与其他模块集成，例如，节点之间的所有通信都使用 Transport 模块完成。节点使用发现机制通过 Ping 的方式查找其他节点。

Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。

如果集群的节点运行在不同的机器上，使用单播，你可以为 Elasticsearch 提供一些它应该去尝试连接的节点列表。当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系 master 节点，并加入集群。

这意味着单播列表不需要包含集群中的所有节点，它只是需要足够的节点，当一个新节点联系上其中一个并且说上话就可以了。如果你使用 master 候选节点作为单播列表，你只要列出三个就可以了。这个配置在 elasticsearch.yml 文件中：

```text
discovery.zen.ping.unicast.hosts: ["host1", "host2:port"]
```

