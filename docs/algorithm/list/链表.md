# 1、概念

链表（Linked List）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针（Pointer）。

# 2、特点

## 2.1 效率
- 插入：O（1）
- 访问：O（n）

由于不必须按顺序存储，链表在插入的时候可以达到 O(1) 的复杂度，比另一种线性表 —— 顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要 O(n) 的时间，而顺序表相应的时间复杂度分别是 O(log n) 和 O(1)。

## 2.2 优点
使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。

## 2.3 缺点
链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

## 2.4 常见的链表
- 单向链表
- 单向循环链表
- 双向链表
- 双向循环链表

## 2.5 单向链表组成
- 存储数据元素的数据域
- 存储下一个结点地址的指针域

# 3、单链表实现

## 3.1 定义结构体
```go
type Object interface{}

type Node struct {
    Data Object //定义数据域
    Next *Node  //定义地址域(指向下一个表的地址)
}

type List struct {
    headNode *Node //头节点
}
```

## 3.2 判断链表是否为空
```go
// 判断链表是否为空
func (list *List) IsEmpty() bool {
    return list.headNode == nil
}
```

## 3.3 获取列表长度
```go
// 获取列表长度
func (list *List) Length() int {
    //获取链表头结点
    cur := list.headNode
    //定义一个计数器，初始值为0
    count := 0
    
    for cur != nil {
        //如果头节点不为空，则count++
        count++
        //对地址进行逐个位移
        cur = cur.Next
    }
    return count
}
```

## 3.4 从链表头部添加元素
```go
// 从链表头部添加元素
func (list *List) Add(data Object) *Node {
    node := &Node{Data: data}
    node.Next = list.headNode
    list.headNode = node
    return node
}
```

## 3.5 从链表尾部添加元素
```go
// 从链表尾部添加元素
func (list *List) Append(data Object) {
    node := &Node{Data: data}
    if list.IsEmpty() {
        list.headNode = node
    } else {
        cur := list.headNode
        for cur.Next != nil {
            cur = cur.Next
        }
        cur.Next = node
    }
}
```

## 3.6 在链表指定位置添加元素
```go
// 在链表指定位置添加元素
func (list *List) Insert(index int, data Object) {
    if index < 0 {
        list.Add(data)
    } else if index > list.Length() {
        list.Append(data)
    } else {
        pre := list.headNode
        count := 0
        for count < index-1 {
            pre = pre.Next
            count++
        }
        node := &Node{Data: data}
        node.Next = pre.Next
        pre.Next = node
    }
}
```

## 3.7 删除链表指定值的元素
```go
// 删除链表指定值的元素
func (list *List) Remove(data Object) {
    pre := list.headNode
    if pre.Data == data {
        list.headNode = pre.Next
    } else {
        for pre.Next != nil {
            if pre.Next.Data == data {
                pre.Next = pre.Next.Next
            } else {
                pre = pre.Next
            }
        }
    }
}
```

## 3.8 删除指定位置的元素
```go
// 删除指定位置的元素
func (list *List) RemoveAtIndex(index int) {
    pre := list.headNode
    if index < 0 {
        list.headNode = pre.Next
    } else if index > list.Length() {
        return
    } else {
        count := 0
        for count != index-1 && pre.Next != nil {
            count++
            pre = pre.Next
        }
        pre.Next = pre.Next.Next
    }
}
```

## 3.9 查看链表是否包含某个元素
```go
// 查看链表是否包含某个元素
func (list *List) Contain(data Object) bool {
    cur := list.headNode
    for cur != nil {
        if cur.Data == data {
            return true
        }
        cur = cur.Next
    }
    return false
}
```

## 3.10 遍历链表所有节点
```go
// 遍历链表所有节点
func (list *List) ShowList() {
    if !list.IsEmpty() {
        cur := list.headNode
        for cur != nil {
            fmt.Println(cur.Data)
            cur = cur.Next
        }
    }
}
```

# 4、相关题型
## 4.1 简单题型
### leetcode 21. 合并两个有序链表

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：
```go
输入: 1->2->4, 1->3->4
输出: 1->1->2->3->4->4
```

题解：

该题目主要考察的是链表的遍历，首先构造一个新的链表作为返回的结果，然后遍历输入的两个链表，将数字较小的值添加到新的链表中。

这里需要注意的是需要定义一个指针用于遍历新的链表，最终返回的是伪造的 head 的 next 指针。

![p21](/docs/img/链表/p21.png)

实现如下：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    cur1, cur2 := l1, l2
    result := &ListNode{}
    cur := result
    for cur1 != nil && cur2 != nil {
        if cur1.Val >= cur2.Val {
            node := &ListNode{Val:cur2.Val}
            cur.Next = node
            cur = cur.Next
            cur2 = cur2.Next
        } else {
            node := &ListNode{Val:cur1.Val}
            cur.Next = node
            cur = cur.Next
            cur1 = cur1.Next
        }
    }
    for cur1 != nil {
        cur.Next = cur1
        cur = cur.Next
        cur1 = cur1.Next
    }
    for cur2 != nil {
        cur.Next = cur2
        cur = cur.Next
        cur2 = cur2.Next
    }
    return result.Next
}

```

# 4、思维导图
链表的思维导图的原件以及 PDF 在 [链表思维导图](/docs/mind/链表) 下面，有需要的可以下载以便随时查看。

![链表](/docs/mind/链表/链表.jpg)