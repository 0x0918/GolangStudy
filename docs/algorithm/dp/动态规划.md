# 1、动态规划概念

## 1.1 基本概念
动态规划是一种用途很广的问题求解方法，它本身并不是一个特定的算法，而是一种思想，一种手段。

### 1.1.1 算法三要素
1. 所有不同的子问题组成的表
2. 解决问题的依赖关系可以看成是一个图
3. 填充子问题的顺序，对 2 的图进行拓扑排序，填充的过程称为状态转移

### 1.1.2 分类
- 线性动规：线性结构上进行状态转移DP
    - 子集和问题
    - LIS问题（最长上升子序列）
    - LCS问题（最长公共子序列）
    - 子段和问题
- 区域动规：区间模型的状态表示一般为 d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解
- 树形动规：状态图是一棵树，状态转移也发生在树上，父结点的值通过所有子结点计算完毕后得
- 背包动规：[背包九讲](https://github.com/tianyicui/pack)
- 状态压缩模型:一般处理的是数据规模较小的问题，将状态压缩成k进制的整数，k取2时最为常见

## 1.2 设计一个动态规划算法
1. 描述最优解的结构
    1. 问题的一个解可以是做一个选择
    2. 假设对一个给定的问题，已知的是一个可以导致最优解的选择
    3. 在已知这个选择后，要确定哪些子问题会随之发生，以及如何最好的描述所得到的子问题空间
    4. 利用一种剪贴技术，来证明在问题的一个最优解中，使用的子问题的解本身也必须是最优的
2. 递归定义最优解的值
3. 按自底向上的方式计算最优解的值
4. 由计算出的结果构造一个最优解

## 1.3 什么时候需要用到动态规划
- 问题的目标是求一个问题的最优解
- 整体问题的最优解依赖于各个子问题的最优解
- 把大问题分解成若干个小问题，这些小问题之间还有相互重叠的更小的子问题
- 从上往下分析问题，从下往上解决问题

## 1.4 分治和动规有什么区别
- 分治会做许多不必要的工作，会反复求解那些公共子问题
- 动态规划每个子问题只会求解一次，避免了重复的计算工作

# 2、相关题目
后面会从简单到难来讲解题目，目的是让大家能够慢慢的熟悉动态规划。

## 2.1 简单题型
### leetcode 70 爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

题解

爬到第 n 阶，要么从第 n-1 阶爬 1 步达到，要么从第 n-2 阶爬 2 步达到。

所以递推公式为 d[p] = d[p-1] + d[p-2]

```go
func climbStairs(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	if n == 2 {
		return 2
	}
	oneStep, twoStep, total := 1, 2, 0
	for index := 3; index <= n; index++ {
		total = oneStep + twoStep
		oneStep = twoStep
		twoStep = total
	}
	return total
}
```

### leetcode 53 最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

题解

下面讲两种动规思路:

第一种是从动规概念上面去分析
- 动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans
- 如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字
- 如果 sum <= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字
- 每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果
- 时间复杂度：O(n)O(n)

第二种是从状态转移方程角度去分析

用dp[i]表示以i结尾的最大子序列和。初始值 dp[0] = nums[0]，然后从第二个数开始遍历

- if 当前数加上前一个最大序列和大于当前数，则将当前数加到序列和中，nums[i] + dp[i-1] > nums[i]，则 dp[i] = nums[i] + dp[i-1];
- else 以当前数结尾的最大序列和即为当前数本身 dp[i] = nums[i]


## 2.2 中等题型

## 2.3 高难题型

# 3、参考资料
- [麻省理工学院公开课：算法导论 动态规划，最长公共子序列](http://open.163.com/newview/movie/free?pid=M6UTT5U0I&mid=M6V2U1HL4)
- [动态规划：从新手到专家](http://hawstein.com/2013/03/26/dp-novice-to-advanced/)