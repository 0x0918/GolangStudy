# 1、排序算法总结

## 1.1 各排序算法的复杂度

![排序算法复杂度](/docs/img/排序算法/排序算法复杂度.png)

## 1.2 算法复杂度与初始状态无关
算法复杂度与初始状态无关，实际上就是指算法最好情况和最坏情况一致。

计数排序有点特殊，虽然最好情况和最坏情况复杂度一致，都为 O(n+k) 但是计数排序实际上依赖于数字的分布，如果所有数字比较集中的话，那么算法效率比较高，如果数字差距比较大的话，例如包含 1 和 10^9 这样的数字的话，那效率会比较差。

所以排除计数排序之后，算法复杂度与初始状态无关的算法有以下几种：

- 选择排序
- 归并排序
- 堆排序
- 基数排序

## 1.3 总排序趟数与初始状态有关
- 快速排序
- 优化过后的冒泡排序

快速排序趟数与递归深度有关，递归深度可以理解为系统栈保存的深度。

例如{50,10,90,30,70,40,80,60,20}在快速排序过程中的递归过程。由于我们的第一个关键字是 50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好。

例如{10,20,30,40,50,60,70,80,90}第一个关键字是 10，构造出的递归树是不平衡的，性能会比较差，递归树的高度也是比较高度的，排序的趟数也是较平衡状态的要更高。

因为优化过后的冒泡排序最好的情况是 1 趟，其他都要大于 1 趟，所以它的趟数与初始状态有关。

## 1.4 元素总比较次数与初始状态无关
- 基数排序
- 选择排序

基数排序不是基于比较的排序算法，所以它的比较次数为 0，与初始状态无关

选择排序比较次数稳定是  n(n-1)/2，与初始状态无关

## 1.5 元素总移动次数与初始状态无关
- 基数排序
- 归并排序

基数排序不论初始数组如何排列，都是从个位开始，各自进入自己个位对应的位置，之后也都是一样，所以元素移动次数一样。

归并排序不论一开始的状态如何，最后都是两个数组进入临时数组，移动次数都为两个待合并数组的长度和，然后再将临时数组内元素全部移动到原来数组进行替换。所以元素移动次数与初始状态无关。