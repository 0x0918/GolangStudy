# Go 源码解读-垃圾回收

> 源码版本：1.17.6

## Golang 的垃圾回收 GC 介绍

Golang GC 与 mutator 线程并发运行，允许多个 GC 线程并行运行。使用了写屏障的并发标记和扫描，是非分代和非压缩的。

> mutator 指的是用户线程，因为可能会改变内存的状态，所以命名为 mutator。

分配是使用每个 P 分割区域隔离的大小来完成的，以最大程度地减少碎片，同时消除常见情况下的锁定。

> P 是 Golang GMP 模型中的 Processor，是 Golang 的处理器但不是电脑 CPU，包含运行 Go 代码的必要资源，也有调度 Goroutine 的能力。

Golang GC 算法分为以下几个步骤，目前 Golang 所使用的 GC 实现是该算法的高级实现。

### 第一步：GC 执行扫描终止

1、STW。这会使得所有的 P 达到 GC 安全点。 

> STW 即 Stop the world。当前运行的所有程序将被暂停。

2、扫描任何未扫描过的 span。只有在预期时间之前强制执行此 GC 周期时，才会有未扫描的 span。GC 周期以 runtime.forcegcperiod 变量为准，默认 2 分钟。

> span 是 Golang 内存管理的基本单位，每个 span 管理指定规格（以 Golang 中的 page 为单位）的内存块，内存池分配出不同规格的内存块就是通过 span 体现出来的，应用程序创建对象就是通过找到对应规格的 span 来存储的。

### 第二步：GC 执行标记阶段

1、通过将 gcphase 设置为 _GCmark（来自于 _GCoff），启用写屏障，启用 mutator 辅助，并且将 GC root 标记为任务队列，为标记阶段作准备。在所有 P 都启用写屏障之前，不能扫描任何对象，这是通过 STW 来实现的。 

> 可达性算法的原理是以一系列叫做 GC root 的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个节点，直到所有的节点都遍历完毕。
> 
> 哪些对象可以作为 GC root呢？
> 
> 1、全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
> 
> 2、执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
> 
> 3、寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些分配的堆内存区块。

2、Start the world。从这个节点开始，GC 工作由调度程序启动的标记 worker 以及分配的一部分 assist 程序来完成。写屏障给任何指针的写入操作屏蔽了被写入的指针和新的指针值（可以参阅 mbarrier.go）。新分配的对象立即被标记为黑色。 

3、GC 执行 GC root 标记作业。这包括扫描所有堆栈，对所有全局变量进行着色，以及对在 off-heap（堆外）runtime 的任何堆指针进行着色。扫描堆栈会停止当前的 goroutine，隐藏在堆栈上找到的任何指针，扫描完成后，会恢复当前 goroutine。 

4、GC 清空灰色对象的工作队列，将每个灰色对象扫描成黑色，并对对象中找到的所有指针进行着色（这反过来可能会将这些指针添加到工作队列中，也就是持续迭代，直到遍历完所有的指针）。

5、由于 GC 工作分布在本地缓存中，因此 GC 使用了一个分布式终止算法来检测何时不再有 GC root 标记作业或灰色对象（参阅 gcMarkDone）。此时，GC 过渡到标记终止。

### 第三步：GC 执行标记终止

1、STW。

2、将 gcphase 设置为 _GCmarktermination，并禁用标记 worker 和 assist 程序。

3、执行刷新 mcache 的清理工作。

### 第四步：GC 执行扫描阶段

