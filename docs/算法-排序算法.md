# 排序算法总结

## 各排序算法总结

- [插入排序](https://cnymw.github.io/go-study/docs/算法-插入排序.html)
- [堆排序](https://cnymw.github.io/go-study/docs/算法-堆排序.html)


## 各排序算法的复杂度

![排序算法复杂度](https://cnymw.github.io/go-study/docs/img/算法-排序算法/算法-排序算法-排序算法复杂度.png)

## 算法复杂度与初始状态无关
算法复杂度与初始状态无关，实际上就是指算法最好情况和最坏情况一致。

计数排序有点特殊，虽然最好情况和最坏情况复杂度一致，都为 O(n+k) 但是计数排序实际上依赖于数字的分布，如果所有数字比较集中的话，那么算法效率比较高，如果数字差距比较大的话，例如包含 1 和 10^9 这样的数字的话，那效率会比较差。

所以排除计数排序之后，算法复杂度与初始状态无关的算法有以下几种：

- 选择排序
- 归并排序
- 堆排序
- 基数排序

## 总排序趟数与初始状态有关
- 快速排序
- 优化过后的冒泡排序

快速排序趟数与递归深度有关，递归深度可以理解为系统栈保存的深度。

例如{50,10,90,30,70,40,80,60,20}在快速排序过程中的递归过程。由于我们的第一个关键字是 50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好。

例如{10,20,30,40,50,60,70,80,90}第一个关键字是 10，构造出的递归树是不平衡的，性能会比较差，递归树的高度也是比较高度的，排序的趟数也是较平衡状态的要更高。

因为优化过后的冒泡排序最好的情况是 1 趟，其他都要大于 1 趟，所以它的趟数与初始状态有关。

## 元素总比较次数与初始状态无关
- 基数排序
- 选择排序

基数排序不是基于比较的排序算法，所以它的比较次数为 0，与初始状态无关

选择排序比较次数稳定是  n(n-1)/2，与初始状态无关

## 元素总移动次数与初始状态无关
- 基数排序
- 归并排序

基数排序不论初始数组如何排列，都是从个位开始，各自进入自己个位对应的位置，之后也都是一样，所以元素移动次数一样。

归并排序不论一开始的状态如何，最后都是两个数组进入临时数组，移动次数都为两个待合并数组的长度和，然后再将临时数组内元素全部移动到原来数组进行替换。所以元素移动次数与初始状态无关。

# 相关题目

## 简单题型
### leetcode 242. 有效的字母异位词
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:
```go
输入: s = "anagram", t = "nagaram"
输出: true
```


示例 2:
```go
输入: s = "rat", t = "car"
输出: false
```

说明:你可以假设字符串只包含小写字母。

题解：

该题比较简单，从排序的思维来看的话，将字符串转化为 int 数组之后，排序完成就能得到从小到大排序好的数组。

然后将两个排序好的数组进行一一比较之后便可知道两个字符串是否是字母异位词了。

以下是实现：

```go
func isAnagram(s string, t string) bool {
    if len(s) != len(t) {
        return false
    }
    sCh, tCh := make([]int, 0), make([]int, 0)
    for _, ch := range s {
        sCh = append(sCh, int(ch))
    }
    for _, ch := range t {
        tCh = append(tCh, int(ch))
    }
    sSort := QuickSort{
        Value: sCh,
    }
    tSort := QuickSort{
        Value: tCh,
    }
    sSort.Sort()
    tSort.Sort()
    for index := 0; index < len(sSort.Value); index++ {
        if sSort.Value[index] != tSort.Value[index] {
            return false
        }
    }
    return true
}

type QuickSort struct {
    Value []int
}

func (q *QuickSort) Sort() () {
    if len(q.Value) <= 1 {
        return
    }
    quickSort(q.Value, 0, len(q.Value)-1)
}

func quickSort(s []int, left, right int) {
    temp, index := s[left], left
    i, j := left, right
    for j >= i {
        // 比temp大的放在右边
        for j >= index && s[j] >= temp {
            j--
        }
        if j >= index {
            s[index] = s[j]
            index = j
        }
    
        // 比temp小的放在左边
        for index >= i && s[i] <= temp {
            i++
        }
        if index >= i {
            s[index] = s[i]
            index = i
        }
    }
    s[index] = temp
    if index-left > 1 {
        quickSort(s, left, index-1)
    }
    if right-index > 1 {
        quickSort(s, index+1, right)
    }
}
```

## 中等题型
### leetcode 56. 合并区间
给出一个区间的集合，请合并所有重叠的区间。

示例 1:
```go
输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

示例 2:
```go
输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间
```

题解：

针对于输入 s = [1,3], t = [2,6]，可以看出 s[1] > t[0]，存在重叠区间，所以 s 和 t 合并之后，左边界取s[0],t[0]中最小的为1，右边界取 s[1] , t[1] 中最大的为6，所以结果为 [1,6]

针对于输入 s = [2,3], t = [1,10]，可以看出 s[1] > t[0]，存在重叠区间，所以 s 和 t 合并之后，左边界取 1，右边界取 10，所以结果为 [1,10]

可以看出，当 s[1] > t[0] 时，即存在重叠区间，左边界取最小值，右边界取最大值。

所以最快的方式是将所有输入按首个数字进行排序，然后再比较 s[1],t[0] 的大小，这样能够保证 s[0] < t[0] 为起始条件，省去了一步判断最小的过程。

以下是实现：

```go
import (
    "math"
    "sort"
)

type Interval struct {
    Value [][]int
}

func merge(intervals [][]int) [][]int {
    if len(intervals) <= 1 {
        return intervals
    }
    interval := new(Interval)
    interval.Value = intervals
    sort.Sort(interval)
    
    result := make([][]int, 0)
    result = append(result, interval.Value[0])
    for i := 1; i < len(interval.Value); i++ {
        if result[end(result)][1] < interval.Value[i][0] {
            result = append(result, interval.Value[i])
        } else {
            result[end(result)][1] = int(math.Max(float64(result[end(result)][1]), float64(interval.Value[i][1])))
        }
    }
    return result
}

func end(i [][]int) int {
    return len(i) - 1
}

func (interval *Interval) Len() int {
    return len(interval.Value)
}

func (interval *Interval) Less(i, j int) bool {
    return interval.Value[i][0] < interval.Value[j][0]
}

func (interval *Interval) Swap(i, j int) {
    interval.Value[i], interval.Value[j] = interval.Value[j], interval.Value[i]
}
```

## 困难题型
### leetcode 164. 最大间距
给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

如果数组元素个数小于 2，则返回 0。

示例 1:

```go
输入: [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3
```

示例 2:
```go
输入: [10]
输出: 0
解释: 数组元素个数小于 2,因此返回 0
```

题解：

找出相邻元素的差值，首先要将所有元素排好序，然后从按序计算差值。

然后将差值集合再按照大小进行排序，最后取最大的差值返回。

以下是 go 实现：
```go
func maximumGap(nums []int) int {
    if len(nums) < 2 {
        return 0
    }
    sort := &QuickSort{
        Value: nums,
    }
    sort.Sort()
    max := 0
    for index := 1; index < len(sort.Value); index++ {
        gap := sort.Value[index] - sort.Value[index-1]
        if gap > max {
            max = gap
        }
    }
    return max
}

type QuickSort struct {
    Value []int
}

func (q *QuickSort) Sort() () {
    if len(q.Value) <= 1 {
        return
    }
    quickSort(q.Value, 0, len(q.Value)-1)
}

func quickSort(s []int, left, right int) {
    temp, index := s[left], left
    i, j := left, right
    for j >= i {
        // 比temp大的放在右边
        for j >= index && s[j] >= temp {
            j--
        }
        if j >= index {
            s[index] = s[j]
            index = j
        }
    
        // 比temp小的放在左边
        for index >= i && s[i] <= temp {
            i++
        }
        if index >= i {
            s[index] = s[i]
            index = i
        }
    }
    s[index] = temp
    if index-left > 1 {
        quickSort(s, left, index-1)
    }
    if right-index > 1 {
        quickSort(s, index+1, right)
    }
}
```

# 思维导图

排序算法的思维导图的原件以及 PDF 在 [排序算法思维导图](https://github.com/cnymw/go-study/tree/master/docs/mind/算法-排序算法) 下面，有需要的可以下载以便随时查看。

![排序算法](https://cnymw.github.io/go-study/docs/img/算法-排序算法/算法-排序算法-思维导图.jpg)