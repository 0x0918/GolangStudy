# 简介

## 概念

- 采用顺序存储结构的线性表简称为顺序表。
- 线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。
- 顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。

## 特点

- 只要确定了起始位置，表中任一元素的地址都通过下列公式得到：LOC（ai）=LOC（a1）+（i-1）*L 　1≤i≤n 其中，L 是元素占用存储单元的长度。

## 元素

- 顺序表申请的存储容量
- 顺序表的长度，也就是表中存储数据元素的个数

正常状态下，顺序表申请的存储容量要大于或等于顺序表的长度。

在 go 中，内置的 len 和 cap 函数分别返回 slice 和数组的长度和容量。

slice 的容量会根据实际的长度来动态的扩大，每次达到最大容量的时候会扩大一倍。

```go
func main() {
    var x, y []int
    for i := 0; i < 10; i++ {
        y = appendInt(x, i)
        fmt.Printf("%d cap=%d\t%v\n", i, cap(y), y)
        x = y
    }
}

0  cap=1    [0]
1  cap=2    [0 1]
2  cap=4    [0 1 2]
3  cap=4    [0 1 2 3]
4  cap=8    [0 1 2 3 4]
5  cap=8    [0 1 2 3 4 5]
6  cap=8    [0 1 2 3 4 5 6]
7  cap=8    [0 1 2 3 4 5 6 7]
8  cap=16   [0 1 2 3 4 5 6 7 8]
9  cap=16   [0 1 2 3 4 5 6 7 8 9]
```

数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。

数组的长度等于容量，定义好之后就不会变了。

```go
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int

fmt.Println(len(q)) // 3
fmt.Println(cap(q)) // 3
```

# 相关题目
## 简单题型

- [leetcode 27 移除元素](https://cnymw.github.io/GolangStudy/docs/leetcode-27-移除元素.html)


## 中等题型

- [leetcode 15 三数之和](https://cnymw.github.io/GolangStudy/docs/leetcode-15-三数之和.html)


# 思维导图

## 图片版

![数据结构-顺序表-思维导图.jpg](https://cnymw.github.io/GolangStudy/docs/img/数据结构-顺序表/数据结构-顺序表-思维导图.jpg)

## pdf

[数据结构-顺序表-思维导图.pdf](https://cnymw.github.io/GolangStudy/docs/img/数据结构-顺序表/数据结构-顺序表-思维导图.pdf)

## 在线查看

[数据结构-顺序表-思维导图.html](https://cnymw.github.io/GolangStudy/docs/img/数据结构-顺序表/数据结构-顺序表-思维导图.html)


