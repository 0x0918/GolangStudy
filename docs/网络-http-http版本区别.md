# HTTP 1.0、1.1、2.0、3.0区别

## HTTP 1.0

### 特点

- 是一种无状态，无连接的应用层协议。 HTTP1.0 规定浏览器和服务器保持短暂的链接。

- 浏览器每次请求都需要与服务器建立一个 TCP 连接，服务器处理完成以后立即断开 TCP 连接(无连接)，服务器不跟踪每个客户单，也不记录过去的请求(无状态)。

- 这种无状态性可以借助 cookie/session 机制来做身份认证和状态记录。

### 存在的问题

- 无法复用连接，每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。

- 队头阻塞(head of line blocking)，由于 HTTP1.0 规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。

- 不支持断点续传，也就是说，每次都会传送全部的页面和数据。

## HTTP 1.1

HTTP1.1 继承了 HTTP1.0 的简单，克服了 HTTP1.0 性能上的问题。

### 特点

- 长连接，HTTP1.1 增加 Connection 字段，对于同一个 host，通过设置 Keep-Alive 保持 HTTP 连接不断。避免每次客户端与服务器请求都要重复建立释放建立 TCP 连接。提高了网络的利用率。如果客户端想关闭
  HTTP 连接，可以在请求头中携带 Connection:false 来告知服务器关闭请求。

- 支持断点续传，通过使用请求头中的 Range 来实现。

- 可以使用管道传输，多个请求可以同时发送，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。

## HTTP 2.0

### 特点

- 二进制分帧，HTTP2.0 通过在应用层和传输层之间增加一个二进制分层帧，突破了 HTTP1.1 的性能限制，改进传输性能。

- 多路复用(链接共享)— 真并行传输

- 头部压缩，在 HTTP1.X 中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加 500-8000 字节的负荷。比如 cookie，默认情况下，浏览器会在每次请求的时候，把 cookie 附在 header
  上面发给服务器。HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header_files 表，既避免重复 header 的传输，又减少了需要传输的大小。
  高效的压缩算法可以很大的压缩 header，减少发送包的数量从而降低延迟。

- 服务器推送，服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的需求。

### 二进制分帧

在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 Headers 帧，而 request body 则封装到 Data 帧里面。

HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。

![网络-http-http版本区别-二进制分帧.jpg](https://cnymw.github.io/GolangStudy/docs/img/网络-http-http版本区别-二进制分帧.jpg)

## HTTP 3.0

- 基于 google 的 QUIC 协议，而 quic 协议是使用 udp 实现的；

- 减少了 tcp 三次握手时间，以及 tls 握手时间；

- 解决了 http 2.0 中前一个 stream 丢包导致后一个 stream 被阻塞的问题；

- 优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗；

- 连接迁移，不再用 tcp 四元组确定一个连接，而是用一个 64 位随机数来确定这个连接；

- 更合适的流量控制。

## 思维导图

