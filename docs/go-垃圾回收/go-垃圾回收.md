# golang 垃圾回收算法

## 常见垃圾回收算法

### 引用计数法

根据对象自身的引用计数来回收，当引用计数归零时进行回收，但是计数频繁更新会带来更多开销，且无法解决循环引用的问题。

- 优点：简单直接，回收速度快
- 缺点：需要额外的空间存放计数，无法处理循环引用的情况

### 标记清除法

标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象。

- 优点：简单直接，速度快，适合可回收对象不多的场景
- 缺点：会造成不连续的内存空间（内存碎片），导致有大的对象创建的适合，内存中总内存是够的，但是空间不是连续的造成对象无法分配

### 复制法

复制法将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉

- 优点：解决了内存碎片的问题，每次清除针对的都是整块内存
- 缺点：有部分内存总是利用不到，资源浪费，移动存活对象比较耗时，并且如果存活对象较多的时候，需要担保机制确保复制区有足够的空间可完成复制

### 标记整理

标记过程同标记清除法，结束后将存活对象压缩至一端，然后清除边界外的内容。

- 优点：解决了内存碎片问题，也不像标记复制法那样需要担保机制，存活对象较多的场景也适用
- 缺点：性能低，因为在移动对象的时候不仅需要移动对象还要维护对象的引用地址，可能需要对内存经过几次扫描才能完成

### 分代式

将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。

并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。

