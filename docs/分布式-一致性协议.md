# 分布式：一致性协议

## 2PC 与 3PC

在分布式系统中，每一个机器节点虽然能够明确地知道自己在进行事务操作过程中的结果是成功或失败，但却无法直接获取到其他分布式节点的操作结果。

因此，当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的 ACID 特性，就需要引入一个称为协调者（Coodinator）的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点被称为参与者（Participant）。

协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。

### 2PC

2PC 是 Two-Phase Commit 的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式架构下的所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。

绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效地保证分布式数据的一致性。

#### 阶段一：提交事务请求

1. 事务询问：协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。
2. 执行事务：各参与者节点执行事务操作，并将 Undo 和 Redo 信息记入事务日志中。
3. 各参与者向协调者反馈事务询问的响应：如果参与者成功执行了事务操作，那么就反馈给协调者 Yes 响应，表示事务可以执行，否则返回 No 响应。

#### 阶段二：执行事务提交

协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，包含以下两种可能：

- 执行事务提交
    1. 发送提交请求：协调者向所有参与者节点发出 Commit 请求
    2. 事务提交：参与者接收到 Commit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源
    3. 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送 Ack 消息
    4. 完成事务：协调者接收到所有参与者反馈的 Ack 消息后，完成事务
    
- 中断事务
    1. 发送回滚请求：协调者向所有参与者节点发出 Rollback 请求
    2. 事务回滚：参与者接收到 Rollback 请求后，会利用其在阶段一中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源
    3. 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送 Ack 消息
    4. 中断事务：协调者接收到所有参与者反馈的 Ack 消息后，完成事务中断
    

#### 优缺点

二阶段提交协议的优点：原理简单，实现方便

二阶段提交协议的缺点：

- 同步阻塞：在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作
- 单点问题：协调者的角色在二阶段提交协议中起到了非常重要的作用，一旦协调者出现问题，那么整个流程将无法运转，更为严重的是，如果在阶段二出现问题的话，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作
- 数据不一致：执行事务提交的时候，当协调者向所有的参与者发送 Commit 请求之后，发生了局部网络异常或者是协调者在尚未发送完 Commit 之前自身发生了崩溃，导致只有部分参与者收到了 Commit 请求，于是整个分布式系统出现了数据不一致性现象
- 太过保守：如果在协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠自身的超时机制来判断是否需要中断事务，这样的策略显得比较保守

### 3PC

3PC 是 Three-Phase Commit 的缩写，即三阶段提交，是 2PC 的改进版，其将二阶段提交协议的"提交事务请求"过程一分为二，形成了 CanCommit，PreCommit 和 DoCommit 三个阶段组成的事务处理协议

#### 阶段一：CanCommit

1. 事务询问：协调者向所有的参与者发送一个包含事务内容的 CanCommit 请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应
2. 各参与者向协调者反馈事务询问的响应：参与者在接收到来自协调者的 CanCommit 请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈 Yes 响应，并进入预备状态，否则反馈 No 响应

#### 阶段二：PreCommit

阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的 PreCommit 操作，包含两种可能：

- 执行事务预提交
    1. 发送预提交请求：协调者向所有参与者节点发出 PreCommit 请求，并进入 Prepared 阶段
    2. 事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中
    3. 各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就会反馈给协调者 Ack 响应，同时等待最终的指令：提交（Commit）或终止（Abort）
    
- 中断事务
    1. 发送中断请求：协调者向所有参与者节点发出 abort 请求
    2. 中断事务：无论是收到来自协调者的 abort 请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务
    

#### 阶段三：DoCommit

该阶段将进行真正的事务提交，会存在以下两种可能的情况

- 执行提交
    1. 发送提交请求：协调者处于正常工作状态，并且接收到了来自所有参与者的 Ack 响应，那么它将从"预提交"状态转换到"提交"状态，并向所有的参与者发送 DoCommit 请求
    2. 事务提交：参与者接收到 DoCommit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源
    3. 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送 Ack 消息
    4. 完成事务：协调者接收到所有参与者反馈的 Ack 消息后，完成事务
    
- 中断事务
    1. 发送中断请求：协调者向所有的参与者发送 abort 请求
    2. 事务回滚：参与者接收到 abort 请求后，会利用其在阶段二中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放占用的资源
    3. 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送 Ack 消息
    4. 中断事务：协调者接收到所有参与者反馈的 Ack 消息后，中断事务
    

#### 优缺点

三阶段提交协议的优点：降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致

缺点：在参与者接收到 PreCommit 消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然会出现数据的不一致性

## Paxos 算法

### 问题描述

假设有一组可以提出提案的进程集合，那么对于一个一致性算法来说需要保证以下几点：

- 在这些被提出的提案中，只有一个会被选定
- 如果没有提案被提出，那么就不会有被选定的提案
- 当一个提案被选定后，进程应该可以获取被选定的提案信息

对于一致性来说，安全性（Safety）需求如下：

- 只有被提出的提案才能被选定（Chosen）
- 只能有一个值被选定
- 如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个

在 Paxos 算法中，有三种参与角色：

- Proposer
- Acceptor
- Learner

假设不同参与者之间可以通过收发消息来进行通信，那么：

- 每个参与者以任意的速度执行，可能会因为出错而停止，也可能会重启。同时，即使一个提案被选定后，所有的参与者也都有可能失败或重启，因此除非那些失败或重启的参与者可以记录某些信息，否则将无法确定最终的值
- 消息在传输过程中可能会出现不可预知的延迟，也可能会重复或丢失，但是消息不会被损坏，即消息内容不会被篡改

### 提案的选定

要选定一个唯一提案最简单的方法莫过于只允许一个 Acceptor 存在，但一旦这个 Acceptor 出现问题，那么整个系统就无法工作了。

可以使用多个 Acceptor 来避免 Acceptor 的单点问题。