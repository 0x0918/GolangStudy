# B 树

B 树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树。

## 辅助存储上的数据结构

- 主存：通常由硅存储芯片组成，这种技术每位的存储代价一般要比磁存储技术（磁带，磁盘）高不止一个数量级，主存的价格和性能都特别高。一般主存的大小在 GB 级别。
  
- 辅存：一般基于磁盘，这种辅存的容量通常要比主存的容量高出至少两个数量级。磁盘的容量一般可以达到 TB 级别，但是性能较主存差很多。

在一个典型的 B 树应用中，所要处理的数据量非常大，以至于所有数据无法一次装入主存。B 树算法将所需页面从磁盘复制到主存，然后将修改过的页面写回磁盘。

在任何时刻，B 树算法都只需在主存中保持一定数量的页面。因此，主存的大小并不限制被处理的 B 树的大小。

## B 树的定义

一棵 B 树 T 是具有以下性质的有根树（根为 T.root）

1. 每个结点有如下属性： 
   
   a. x.n，当前存储在结点 x 中的关键字个数 
   
   b. x.n 个关键字本身 x.key1,x.key2,...,x.keyn，以非降序存放，使得 x.key1<=x.key2<=...<=x.keyn
   
   c. x.leaf，一个布尔值，如果 x 是叶结点，则为 TRUE；如果 x 为内部结点，则为 FALSE。
   
2. 每个内部结点 x 还包含 x.n+1 个指向其孩子的指针 x.c1,x.c2,...,x.c+n1。叶结点没有孩子，所以它们的 ci 属性没有定义。
   
3. 关键字 x.keyi 对存储在各子树中的关键字范围加以分割：如果 ki 为任意一个存储在以 x.ci 为根的子树中的关键字，那么：k1<=x.key1<=k2<=x.key2<=...<=x.keyn<=kn+1

4. 每个叶结点具有相同的深度，即树的高度 h

5. 每个结点所包含的关键字个数有上界和下界。用一个被称为 B 树的最小度数的固定整数 t>=2 来表示这些界 
   
   a. 除了根结点以外的每个结点必须至少有 t-1 个关键字。因此，除了根结点以外的每个内部结点至少有 t 个孩子。如果树非空，根结点至少有一个关键字。
   
   b. 每个结点至多可包含 2t-1 个关键字。因此，一个内部结点至多可有 2t 个孩子。当一个结点恰好有 2t-1 个关键字时，则称该结点是满的( t=2 时的 B 树是最简单的，每个内部结点有 2 个，3 个或 4 个孩子，即一棵 2-3-4 树)
   

## B 树上的基本操作

在讲基本操作之前，我们先采用两个约定：

- B 树的根结点始终在主存中，这样无需对根做 DISK-READ 操作。然而，当根结点被改变后，需要对根结点做一次 DISK-WRITE 操作。

- 任何被当作参数的结点在被传递之前，都要对它们先做一次 DISK-READ 操作。

### 搜索 B 树

搜索 B 树分为以下四个步骤：

1. 找出最小下标 i，使得 k<= x.keyi，若找不到，则置 i 为 x.n+1

2. 检查是否已经找到了该关键字，如果找到，则返回

3. 如果没有找到同时 x 是叶结点，则结束这次不成功查找

4. 如果 x 不是叶结点，在对孩子结点执行必要的 DISK-READ 后，递归搜索 x 的相应子树

![数据结构-B树-搜索B树伪代码.png](https://cnymw.github.io/GolangStudy/docs/img/数据结构-B树-搜索B树伪代码.png)

### 创建一个空的 B 树

为了构造一棵 B 树，先得调用 B-TREE-CREATE 创建一个空的根结点，然后调用 B-TREE-INSERT 添加新的关键字。

会用到一个辅助过程 ALLOCATE-NODE，这个方法的作用是为一个新结点分配一个磁盘页。

![数据结构-B树-创建一个空的B树伪代码.png](https://cnymw.github.io/GolangStudy/docs/img/数据结构-B树-创建一个空的B树伪代码.png)
